<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play - Naitya Tic Tac Toe Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 1.5rem;
            background: linear-gradient(45deg, #2196F3, #64B5F6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            padding-top: 10px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .room-code-banner {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }

        .room-code-banner h3 {
            font-size: 0.9rem;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .room-code-banner .code {
            font-size: 1.8rem;
            font-weight: bold;
            letter-spacing: 5px;
            font-family: 'Courier New', monospace;
        }

        .turn-indicator {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .score {
            display: flex;
            gap: 30px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 0.9rem;
            color: #aaa;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: start;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        .board-wrapper {
            position: relative;
            display: inline-block;
        }

        .board-coordinates {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            font-weight: 600;
        }

        .coord-row {
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
        }

        .coord-col {
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            grid-template-rows: repeat(4, 100px);
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        /* Flip board for Red player (guest) */
        .board.flipped {
            transform: rotate(180deg);
        }

        /* Coordinate labels on board squares */
        .coord-label {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.7rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            z-index: 1;
        }

        /* Keep pieces upright when board is flipped */
        .board.flipped .piece {
            transform: rotate(180deg);
        }

        /* Coordinate labels stay in correct orientation (no counter-rotation needed) */

        .square {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #8B4513, #A0826D);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
            position: relative;
        }

        .square:hover {
            transform: scale(1.05);
            border-color: #2196F3;
        }

        .square.selected {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .square.valid-move {
            border-color: #4CAF50;
            background: linear-gradient(135deg, #8B4513, #4CAF50);
        }

        .square.valid-move::after {
            content: '‚óè';
            position: absolute;
            color: #4CAF50;
            font-size: 1.5rem;
            opacity: 0.5;
        }

        .piece {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .player1-piece {
            color: #64B5F6 !important;
            text-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
        }

        .player2-piece {
            color: #EF5350 !important;
            text-shadow: 0 0 10px rgba(239, 83, 80, 0.5);
        }

        /* Ensure flipped pieces keep their colors */
        .board.flipped .player1-piece {
            color: #64B5F6 !important;
        }

        .board.flipped .player2-piece {
            color: #EF5350 !important;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #64B5F6;
        }

        .piece-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .piece-btn {
            background: rgba(33, 150, 243, 0.3);
            border: 2px solid #2196F3;
            padding: 15px;
            border-radius: 10px;
            color: #64B5F6;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .piece-btn:hover {
            background: rgba(33, 150, 243, 0.5);
            transform: scale(1.05);
        }

        .piece-btn.selected {
            background: rgba(33, 150, 243, 0.7);
            border-color: #FFD700;
        }

        .piece-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Red piece buttons for guest player */
        .piece-btn.red-pieces {
            background: rgba(239, 83, 80, 0.3);
            border: 2px solid #EF5350;
            color: #EF5350;
        }

        .piece-btn.red-pieces:hover {
            background: rgba(239, 83, 80, 0.5);
        }

        .piece-btn.red-pieces.selected {
            background: rgba(239, 83, 80, 0.7);
            border-color: #FFD700;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .btn.danger {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .move-history {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .move-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            border: 3px solid;
        }

        .modal-content.win {
            border-color: #4CAF50;
        }

        .modal-content.lose {
            border-color: #f44336;
        }

        .modal-content.draw {
            border-color: #FF9800;
        }

        .modal-content h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .modal-content .emoji {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .difficulty-selector {
            margin-bottom: 20px;
        }

        .difficulty-selector label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
        }

        .difficulty-selector select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #2196F3;
            font-size: 1rem;
        }

        @media (max-width: 1024px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            /* Move board to center/top - it should be second after piece selector */
            .board-container {
                order: 1;
            }

            /* Piece selector first (most important for player) */
            .sidebar:first-of-type {
                order: 0;
            }

            /* Opponent pieces and info last */
            .sidebar:last-of-type {
                order: 2;
            }

            .board {
                grid-template-columns: repeat(4, 70px);
                grid-template-rows: repeat(4, 70px);
                gap: 5px;
                padding: 10px;
            }

            .square {
                width: 70px;
                height: 70px;
                font-size: 2.2rem;
            }

            h1 {
                font-size: 1.2rem;
            }

            .game-info {
                flex-direction: column;
                padding: 15px;
                gap: 10px;
            }

            .piece-btn {
                padding: 12px;
                font-size: 1.8rem;
            }

            .move-history {
                max-height: 150px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 0;
            }

            .header {
                margin-bottom: 15px;
            }

            .game-info {
                margin-bottom: 15px;
                padding: 10px;
            }

            .board {
                grid-template-columns: repeat(4, 65px);
                grid-template-rows: repeat(4, 65px);
                gap: 4px;
                padding: 8px;
            }

            .square {
                width: 65px;
                height: 65px;
                font-size: 2rem;
            }

            h1 {
                font-size: 1.1rem;
            }

            .piece-btn {
                padding: 10px;
                font-size: 1.6rem;
            }

            .sidebar {
                padding: 15px;
            }

            .move-history {
                max-height: 120px;
            }

            .room-code-banner {
                padding: 10px 15px;
                margin-bottom: 15px;
            }

            .room-code-banner .code {
                font-size: 1.4rem;
                letter-spacing: 3px;
            }
        }

        .status-message {
            text-align: center;
            padding: 15px;
            background: rgba(33, 150, 243, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .back-btn {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #2196F3;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .back-btn:hover {
            background: rgba(33, 150, 243, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-btn">‚Üê Back to Menu</a>
            <h1>üéÆ Naitya Tic Tac Toe Chess ‚ôüÔ∏è</h1>
        </div>

        <!-- Room Code Banner (shown in multiplayer) -->
        <div class="room-code-banner" id="roomCodeBanner" style="display: none;">
            <h3>Room Code</h3>
            <div class="code" id="displayRoomCode">------</div>
        </div>

        <div class="game-info">
            <div class="turn-indicator" id="turnIndicator">Your Turn (Blue)</div>
            <div class="score">
                <div class="score-item">
                    <div class="score-label">Round</div>
                    <div class="score-value" id="roundNumber">1</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Phase</div>
                    <div class="score-value" id="gamePhase">Placement</div>
                </div>
            </div>
            <div class="difficulty-selector">
                <select id="difficulty">
                    <option value="easy">Easy AI</option>
                    <option value="medium" selected>Medium AI</option>
                    <option value="hard">Hard AI</option>
                </select>
            </div>
        </div>

        <div class="status-message" id="statusMessage">
            Place your pieces on the board. Click a piece below, then click an empty square.
        </div>

        <div class="game-container">
            <div class="sidebar">
                <h3 id="yourPiecesLabel">Your Pieces (Blue)</h3>
                <div class="piece-selector" id="pieceSelector">
                    <button class="piece-btn" data-piece="pawn">‚ôô</button>
                    <button class="piece-btn" data-piece="rook">‚ôñ</button>
                    <button class="piece-btn" data-piece="knight">‚ôò</button>
                    <button class="piece-btn" data-piece="bishop">‚ôó</button>
                </div>

                <h3>Actions</h3>
                <div class="controls">
                    <button class="btn" onclick="deselectAll()">Deselect</button>
                    <button class="btn secondary" onclick="newGame()">New Game</button>
                    <button class="btn danger" onclick="location.href='index.html'">Quit</button>
                </div>

                <h3 style="margin-top: 20px;">Move History</h3>
                <div class="move-history" id="moveHistory"></div>
            </div>

            <div class="board-container">
                <div class="board-wrapper">
                    <div class="board" id="board"></div>
                </div>
            </div>

            <div class="sidebar">
                <h3 id="opponentPiecesLabel">AI Pieces (Red)</h3>
                <div class="piece-selector" id="opponentPieceSelector">
                    <button class="piece-btn" disabled>‚ôü</button>
                    <button class="piece-btn" disabled>‚ôú</button>
                    <button class="piece-btn" disabled>‚ôû</button>
                    <button class="piece-btn" disabled>‚ôù</button>
                </div>

                <h3>Game Info</h3>
                <div style="line-height: 2; color: #aaa; font-size: 0.9rem;">
                    <p><strong>Goal:</strong> Get 4 in a row</p>
                    <p><strong>Rounds 1-3:</strong> Place pieces</p>
                    <p><strong>Round 4+:</strong> Place or move</p>
                    <p><strong>Tip:</strong> Think ahead!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal" id="gameModal">
        <div class="modal-content" id="modalContent">
            <div class="emoji" id="modalEmoji">üéâ</div>
            <h2 id="modalTitle">You Win!</h2>
            <p id="modalMessage">Congratulations! You got 4 in a row!</p>
            <button class="btn" onclick="newGame()" style="margin-top: 20px;">Play Again</button>
            <button class="btn secondary" onclick="location.href='index.html'" style="margin-top: 10px;">Back to Menu</button>
        </div>
    </div>

    <script src="game-logic.js"></script>
    <script src="config.js"></script>

    <script>
        // Configuration
        const API_URL = CONFIG.getAPIURL(); // Auto-detect based on environment

        // Game state
        let gameState = null;
        let selectedPiece = null;
        let selectedSquare = null;
        let difficulty = 'medium';
        let guestId = null;
        let username = null;
        let isMultiplayer = false;
        let multiplayerRole = null; // 'host' or 'guest'
        let roomCode = null;
        let myPlayer = 'player1'; // 'player1' for host, 'player2' for guest
        let myMoveIndex = 0; // Track which moves we've already processed
        let pollInterval = null;

        // Get or create guest ID
        function getGuestId() {
            let storedId = localStorage.getItem('guestId');
            if (!storedId) {
                // Generate unique guest ID
                storedId = 'guest_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                localStorage.setItem('guestId', storedId);
            }
            return storedId;
        }

        // Get or create username
        function getUsername() {
            let storedName = localStorage.getItem('username');
            if (!storedName) {
                storedName = 'Guest_' + Math.random().toString(36).substring(2, 7).toUpperCase();
                localStorage.setItem('username', storedName);
            }
            return storedName;
        }

        // Initialize user
        function initUser() {
            guestId = getGuestId();
            username = getUsername();
            console.log('üéÆ Guest ID:', guestId);
            console.log('üë§ Username:', username);

            // Display username in the UI
            document.getElementById('turnIndicator').textContent = `${username} (Blue)`;
        }

        // Check if this is a multiplayer game
        function checkMultiplayerMode() {
            const urlParams = new URLSearchParams(window.location.search);
            roomCode = urlParams.get('room');
            multiplayerRole = urlParams.get('role');

            console.log('üîç Checking URL params:', window.location.search);
            console.log('üîç Room code:', roomCode);
            console.log('üîç Role:', multiplayerRole);

            if (roomCode && multiplayerRole) {
                isMultiplayer = true;
                console.log('üéÆ Multiplayer Mode ACTIVATED:', multiplayerRole, 'in room', roomCode);

                // Show room code banner
                const banner = document.getElementById('roomCodeBanner');
                const codeDisplay = document.getElementById('displayRoomCode');

                console.log('üîç Banner element:', banner);
                console.log('üîç Code display element:', codeDisplay);

                if (banner) {
                    banner.style.display = 'block';
                    console.log('‚úÖ Banner display set to block');
                }

                if (codeDisplay) {
                    codeDisplay.textContent = roomCode;
                    console.log('‚úÖ Room code text set to:', roomCode);
                }

                // Hide AI difficulty selector
                const difficultySelector = document.querySelector('.difficulty-selector');
                if (difficultySelector) {
                    difficultySelector.style.display = 'none';
                    console.log('‚úÖ AI selector hidden');
                }

                return true;
            }
            console.log('‚ùå Multiplayer mode NOT activated');
            return false;
        }

        // Update your piece symbols based on player
        function updateYourPieceSymbols(player) {
            const pieceButtons = document.querySelectorAll('#pieceSelector .piece-btn');
            if (player === 'player2') {
                // Red pieces for guest - same symbols, different color
                pieceButtons.forEach(btn => btn.classList.add('red-pieces'));
            } else {
                // Blue pieces for host - same symbols, different color
                pieceButtons.forEach(btn => btn.classList.remove('red-pieces'));
            }
            // Both players use same piece symbols
            pieceButtons[0].textContent = '‚ôü'; // pawn
            pieceButtons[1].textContent = '‚ôú'; // rook
            pieceButtons[2].textContent = '‚ôû'; // knight
            pieceButtons[3].textContent = '‚ôù'; // bishop
        }

        // Update opponent piece symbols based on player
        function updateOpponentPieceSymbols(player) {
            const opponentButtons = document.querySelectorAll('#opponentPieceSelector .piece-btn');
            // Both players use same piece symbols
            opponentButtons[0].textContent = '‚ôü'; // pawn
            opponentButtons[1].textContent = '‚ôú'; // rook
            opponentButtons[2].textContent = '‚ôû'; // knight
            opponentButtons[3].textContent = '‚ôù'; // bishop
        }

        // Initialize game
        function initGame() {
            initUser();

            // Check if multiplayer mode
            checkMultiplayerMode();

            if (isMultiplayer) {
                // Set which player we are
                if (multiplayerRole === 'host') {
                    myPlayer = 'player1'; // Host is Blue
                    gameState = createGame(username, 'Opponent');
                    console.log('üéÆ You are BLUE (Player 1 - Host)');

                    // Update UI labels for host
                    document.getElementById('yourPiecesLabel').textContent = 'Your Pieces (Blue)';
                    document.getElementById('opponentPiecesLabel').textContent = 'Opponent Pieces (Red)';
                    updateOpponentPieceSymbols('player2');

                    // Host: Send initial game state to server
                    sendGameStateToServer();
                } else {
                    myPlayer = 'player2'; // Guest is Red
                    console.log('üéÆ You are RED (Player 2 - Guest)');

                    // Update UI labels for guest - swap colors!
                    document.getElementById('yourPiecesLabel').textContent = 'Your Pieces (Red)';
                    document.getElementById('opponentPiecesLabel').textContent = 'Opponent Pieces (Blue)';
                    updateYourPieceSymbols('player2');
                    updateOpponentPieceSymbols('player1');

                    // Flip the board for Red player
                    document.getElementById('board').classList.add('flipped');

                    // Guest: Fetch initial game state from server
                    fetchGameStateFromServer();
                }

                // Start polling for opponent moves
                startMovePolling();
            } else {
                // Create game for AI
                myPlayer = 'player1';
                gameState = createGame(username, 'AI');

                // Keep default labels for AI mode
                document.getElementById('yourPiecesLabel').textContent = 'Your Pieces (Blue)';
                document.getElementById('opponentPiecesLabel').textContent = 'AI Pieces (Red)';
            }

            selectedPiece = null;
            selectedSquare = null;
            renderBoard();
            updateUI();
            updatePieceSelector();
        }

        // Create board
        function createBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            // Column labels (a, b, c, d)
            const colLabels = ['a', 'b', 'c', 'd'];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);

                    // Add chess-style coordinate label (e.g., "a1", "b2", "c3", "d4")
                    // Row numbers go from 1 (top) to 4 (bottom) from Blue's perspective
                    // For Red player (flipped board), they'll see it upside down which is correct
                    const coordLabel = document.createElement('span');
                    coordLabel.className = 'coord-label';

                    // Chess notation: column letter + row number (from Blue's perspective, row 0 = row 1, row 3 = row 4)
                    const chessNotation = `${colLabels[col]}${row + 1}`;
                    coordLabel.textContent = chessNotation;
                    square.appendChild(coordLabel);

                    board.appendChild(square);
                }
            }
        }

        // Render board
        function renderBoard() {
            if (!document.getElementById('board').children.length) {
                createBoard();
            }

            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const piece = getPieceAt(gameState, row, col);

                // Clear inline styles from winning line highlight
                square.style.backgroundColor = '';
                square.style.boxShadow = '';
                square.style.transform = '';
                square.style.zIndex = '';

                // Remove all children EXCEPT coordinate label
                const coordLabel = square.querySelector('.coord-label');
                square.innerHTML = '';
                if (coordLabel) {
                    square.appendChild(coordLabel);
                }

                square.className = 'square';

                if (piece) {
                    const pieceSymbol = getPieceSymbol(piece.type, piece.player);
                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece ${piece.player === 'player1' ? 'player1-piece' : 'player2-piece'}`;
                    pieceEl.textContent = pieceSymbol;
                    square.appendChild(pieceEl);
                }

                if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                    square.classList.add('selected');
                }
            });

            // Show valid moves if a piece is selected
            if (selectedSquare) {
                showValidMoves(selectedSquare.row, selectedSquare.col);
            }
        }

        // Get piece symbol
        function getPieceSymbol(type, player) {
            // Both players use the same piece symbols, differentiated by color
            const symbols = {
                pawn: '‚ôü',
                rook: '‚ôú',
                knight: '‚ôû',
                bishop: '‚ôù'
            };
            return symbols[type] || '?';
        }

        // Handle square click
        function handleSquareClick(row, col) {
            // In multiplayer, only allow moves when it's your turn
            if (isMultiplayer && gameState.currentPlayer !== myPlayer) return;
            // In AI mode, only allow moves when it's player1's turn
            if (!isMultiplayer && gameState.currentPlayer !== 'player1') return;

            if (gameState.status !== 'in_progress') return;

            const piece = getPieceAt(gameState, row, col);

            // If clicking on own piece in strategy phase, select it for moving
            if (piece && piece.player === myPlayer && gameState.phase === 'strategy') {
                selectedSquare = { row, col };
                selectedPiece = null;
                renderBoard();
                updateStatus('Selected piece. Click a valid square to move.');
                return;
            }

            // If placing a new piece
            if (selectedPiece && !piece) {
                const action = {
                    type: 'place',
                    pieceType: selectedPiece,
                    row: row,
                    col: col
                };

                const result = executeAction(gameState, action);
                if (result.success) {
                    const placedPiece = selectedPiece;
                    selectedPiece = null;
                    renderBoard();
                    updateUI();
                    updatePieceSelector();
                    addMoveToHistoryUI(`You placed ${placedPiece} at (${row},${col})`);

                    // Send move to server in multiplayer
                    if (isMultiplayer) {
                        sendMoveToServer(action);
                    }

                    if (gameState.status === 'in_progress') {
                        if (!isMultiplayer) {
                            setTimeout(aiMove, 800);
                        }
                    } else {
                        checkGameEnd();
                    }
                } else {
                    updateStatus('Invalid move: ' + result.error);
                }
            }

            // If moving a piece
            else if (selectedSquare) {
                const action = {
                    type: 'move',
                    fromRow: selectedSquare.row,
                    fromCol: selectedSquare.col,
                    toRow: row,
                    toCol: col
                };

                const result = executeAction(gameState, action);
                if (result.success) {
                    addMoveToHistoryUI(`You moved from (${selectedSquare.row},${selectedSquare.col}) to (${row},${col})`);
                    selectedSquare = null;
                    renderBoard();
                    updateUI();
                    updatePieceSelector();

                    // Send move to server in multiplayer
                    if (isMultiplayer) {
                        sendMoveToServer(action);
                    }

                    if (gameState.status === 'in_progress') {
                        if (!isMultiplayer) {
                            setTimeout(aiMove, 800);
                        }
                    } else {
                        checkGameEnd();
                    }
                } else {
                    updateStatus('Invalid move: ' + result.error);
                }
            }
        }

        // Show valid moves
        function showValidMoves(row, col) {
            const validMoves = getValidMovesForPiece(gameState, myPlayer, row, col);
            console.log(`Valid moves for piece at (${row},${col}):`, validMoves);
            console.log('Current game phase:', gameState.phase);
            console.log('Current round:', gameState.round);
            validMoves.forEach(move => {
                const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                if (square) {
                    square.classList.add('valid-move');
                }
            });
        }

        // Handle piece selection
        document.querySelectorAll('.piece-btn').forEach(btn => {
            btn.onclick = function() {
                if (this.disabled) return;
                selectedPiece = this.dataset.piece;
                selectedSquare = null;

                document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');

                updateStatus(`Selected ${selectedPiece}. Click an empty square to place it.`);
                renderBoard();
            };
        });

        // Update piece selector
        function updatePieceSelector() {
            // In multiplayer, use myPlayer; in single player, use current player for AI mode
            const playerToCheck = isMultiplayer ? myPlayer : 'player1';
            const playerData = getPlayerData(gameState, playerToCheck);
            const availablePieces = [...playerData.pieces, ...playerData.captured];

            document.querySelectorAll('#pieceSelector .piece-btn').forEach(btn => {
                const pieceType = btn.dataset.piece;
                if (availablePieces.includes(pieceType)) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    btn.disabled = true;
                    btn.style.opacity = '0.3';
                    btn.classList.remove('selected');
                }
            });
        }

        // Deselect all
        function deselectAll() {
            selectedPiece = null;
            selectedSquare = null;
            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
            renderBoard();
            updateStatus('Deselected. Choose a piece or select a piece to move.');
        }

        // AI move
        function aiMove() {
            // Skip AI in multiplayer mode
            if (isMultiplayer) {
                console.log('‚è∏Ô∏è Multiplayer mode - waiting for opponent move');
                updateStatus('Waiting for opponent to make their move...');
                return;
            }

            updateStatus('AI is thinking...');

            setTimeout(() => {
                const aiAction = getAIMove(gameState, 'player2', difficulty);

                if (aiAction) {
                    const result = executeAction(gameState, aiAction);
                    if (result.success) {
                        const moveDesc = aiAction.type === 'place'
                            ? `AI placed ${aiAction.pieceType}`
                            : `AI moved piece`;
                        addMoveToHistoryUI(moveDesc);

                        renderBoard();
                        updateUI();
                        updatePieceSelector();

                        if (gameState.status !== 'in_progress') {
                            checkGameEnd();
                        }
                    }
                }
            }, 500);
        }

        // Update UI
        function updateUI() {
            document.getElementById('roundNumber').textContent = gameState.round;
            document.getElementById('gamePhase').textContent = gameState.phase === 'placement' ? 'Placement' : 'Strategy';

            // Update turn indicator based on current player and multiplayer mode
            if (isMultiplayer) {
                if (gameState.currentPlayer === myPlayer) {
                    const myColor = myPlayer === 'player1' ? 'Blue' : 'Red';
                    document.getElementById('turnIndicator').textContent = `Your Turn (${myColor})`;
                    document.getElementById('turnIndicator').style.color = myPlayer === 'player1' ? '#64B5F6' : '#EF5350';
                } else {
                    const opponentColor = myPlayer === 'player1' ? 'Red' : 'Blue';
                    document.getElementById('turnIndicator').textContent = `Opponent's Turn (${opponentColor})`;
                    document.getElementById('turnIndicator').style.color = myPlayer === 'player1' ? '#EF5350' : '#64B5F6';
                }
            } else {
                // AI mode
                if (gameState.currentPlayer === 'player1') {
                    document.getElementById('turnIndicator').textContent = 'Your Turn (Blue)';
                    document.getElementById('turnIndicator').style.color = '#64B5F6';
                } else {
                    document.getElementById('turnIndicator').textContent = 'AI Turn (Red)';
                    document.getElementById('turnIndicator').style.color = '#EF5350';
                }
            }

            const playerData = getPlayerData(gameState, myPlayer);
            const availableCount = playerData.pieces.length + playerData.captured.length;

            if (gameState.phase === 'placement') {
                updateStatus(`Placement Phase: ${availableCount} pieces available to place.`);
            } else {
                if (availableCount > 0) {
                    updateStatus(`Strategy Phase: ${availableCount} pieces available to place, or move an existing piece.`);
                } else {
                    updateStatus('Strategy Phase: No pieces available to place. Move an existing piece.');
                }
            }
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
        }

        // Add move to history
        function addMoveToHistoryUI(move) {
            const historyEl = document.getElementById('moveHistory');
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.textContent = `Round ${gameState.round}: ${move}`;
            historyEl.insertBefore(moveItem, historyEl.firstChild);
        }

        // Get winning line description
        function getWinningLineDescription() {
            if (!gameState.winningLine || gameState.winningLine.length === 0) {
                return '';
            }

            const positions = gameState.winningLine.map(pos => `(${pos.row},${pos.col})`).join(', ');

            // Determine if horizontal, vertical, or diagonal
            const line = gameState.winningLine;
            if (line.every(pos => pos.row === line[0].row)) {
                return `Horizontal line at row ${line[0].row}: ${positions}`;
            } else if (line.every(pos => pos.col === line[0].col)) {
                return `Vertical line at column ${line[0].col}: ${positions}`;
            } else {
                return `Diagonal line: ${positions}`;
            }
        }

        // Check game end
        function checkGameEnd() {
            // Highlight winning line if there is one
            if (gameState.winningLine && gameState.winningLine.length > 0) {
                console.log('Highlighting winning line:', gameState.winningLine);
                gameState.winningLine.forEach(pos => {
                    const square = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (square) {
                        console.log(`Highlighting square at (${pos.row}, ${pos.col})`);
                        square.style.backgroundColor = '#FFD700';
                        square.style.boxShadow = '0 0 30px rgba(255, 215, 0, 0.8)';
                        square.style.transform = 'scale(1.1)';
                        square.style.zIndex = '100';
                    } else {
                        console.log(`Square not found at (${pos.row}, ${pos.col})`);
                    }
                });
            }

            // Wait 1.5 seconds to show the winning line before displaying modal
            setTimeout(() => {
                const modal = document.getElementById('gameModal');
                const modalContent = document.getElementById('modalContent');
                const modalEmoji = document.getElementById('modalEmoji');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');

                modalContent.className = 'modal-content';

                if (gameState.status === 'player1_won') {
                    // Check if YOU won or opponent won
                    if (myPlayer === 'player1') {
                        modalContent.classList.add('win');
                        modalEmoji.textContent = 'üéâ';
                        modalTitle.textContent = 'You Win!';
                        const winDetails = getWinningLineDescription();
                        modalMessage.textContent = `Congratulations! You got 4 in a row! ${winDetails}`;
                    } else {
                        modalContent.classList.add('lose');
                        modalEmoji.textContent = 'üòî';
                        modalTitle.textContent = isMultiplayer ? 'Opponent Wins!' : 'You Lose!';
                        const winDetails = getWinningLineDescription();
                        modalMessage.textContent = `Better luck next time! ${isMultiplayer ? 'Your opponent' : 'The AI'} got 4 in a row. ${winDetails}`;
                    }
                    modal.classList.add('active');
                } else if (gameState.status === 'player2_won') {
                    // Check if YOU won or opponent won
                    if (myPlayer === 'player2') {
                        modalContent.classList.add('win');
                        modalEmoji.textContent = 'üéâ';
                        modalTitle.textContent = 'You Win!';
                        const winDetails = getWinningLineDescription();
                        modalMessage.textContent = `Congratulations! You got 4 in a row! ${winDetails}`;
                    } else {
                        modalContent.classList.add('lose');
                        modalEmoji.textContent = 'üòî';
                        modalTitle.textContent = isMultiplayer ? 'Opponent Wins!' : 'AI Wins!';
                        const winDetails = getWinningLineDescription();
                        modalMessage.textContent = `Better luck next time! ${isMultiplayer ? 'Your opponent' : 'The AI'} got 4 in a row. ${winDetails}`;
                    }
                    modal.classList.add('active');
                } else if (gameState.status === 'draw') {
                    modalContent.classList.add('draw');
                    modalEmoji.textContent = 'ü§ù';
                    modalTitle.textContent = 'Draw!';
                    modalMessage.textContent = 'No more legal moves. It\'s a tie!';
                    modal.classList.add('active');
                }
            }, 1500); // 1.5 second delay to see the winning line
        }

        // New game
        function newGame() {
            document.getElementById('gameModal').classList.remove('active');
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            initGame();
        }

        // ============================================
        // MULTIPLAYER SYNCHRONIZATION
        // ============================================

        // Send move to server
        async function sendMoveToServer(action) {
            if (!isMultiplayer || !roomCode) {
                console.log('‚ö†Ô∏è Not sending move - not in multiplayer mode');
                return;
            }

            console.log(`üì§ Sending move to server as ${myPlayer}:`, action);
            console.log(`üì§ Sending game state:`, gameState);

            try {
                const response = await fetch(`${API_URL}/api/rooms/move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roomCode: roomCode,
                        player: myPlayer,
                        action: action,
                        gameState: gameState  // Send current game state to server
                    })
                });

                const data = await response.json();
                if (data.success) {
                    console.log(`‚úÖ Move and game state sent to server successfully. Server move index: ${data.moveIndex}, Current myMoveIndex: ${myMoveIndex}`);
                    // Update our move index to skip our own move when polling
                    myMoveIndex = data.moveIndex + 1;
                    console.log(`üìä Updated myMoveIndex to ${myMoveIndex} (will poll from this index)`);
                } else {
                    console.error('‚ùå Failed to send move:', data);
                }
            } catch (error) {
                console.error('‚ùå Error sending move:', error);
            }
        }

        // Poll for opponent moves
        async function checkForOpponentMoves() {
            if (!isMultiplayer || !roomCode) return;

            try {
                console.log(`üîç Polling for moves from index ${myMoveIndex} in room ${roomCode}`);
                const response = await fetch(`${API_URL}/api/rooms/moves/${roomCode}/${myMoveIndex}`);
                const data = await response.json();

                if (data.success && data.moves.length > 0) {
                    console.log(`üì• Received ${data.moves.length} new moves. Current index on server: ${data.currentIndex}`);
                    console.log('üìã Moves received:', data.moves);

                    // CRITICAL FIX: Sync game state from server instead of applying individual moves
                    if (data.gameState) {
                        console.log('üîÑ Syncing game state from server');
                        gameState = data.gameState;
                        console.log('‚úÖ Game state synchronized:', gameState);

                        renderBoard();
                        updateUI();
                        updatePieceSelector();

                        if (gameState.status !== 'in_progress') {
                            checkGameEnd();
                        }
                    } else {
                        console.warn('‚ö†Ô∏è No game state received from server, falling back to move-by-move application');
                        // Fallback: Apply moves individually (old method)
                        for (const move of data.moves) {
                            console.log(`üîé Processing move from ${move.player} (I am ${myPlayer})`);

                            // Only apply moves from the opponent
                            if (move.player !== myPlayer) {
                                console.log('üéÆ Applying opponent move:', move.action);
                                const result = executeAction(gameState, move.action);

                                if (result.success) {
                                    console.log('‚úÖ Opponent move applied successfully');
                                    renderBoard();
                                    updateUI();
                                    updatePieceSelector();

                                    if (gameState.status !== 'in_progress') {
                                        checkGameEnd();
                                    }
                                } else {
                                    console.error('‚ùå Failed to apply opponent move:', result.error);
                                }
                            } else {
                                console.log('‚è≠Ô∏è Skipping my own move');
                            }
                        }
                    }

                    myMoveIndex = data.currentIndex;
                    console.log(`üìä Updated myMoveIndex to ${myMoveIndex}`);
                } else if (data.success) {
                    console.log('‚ú® No new moves');
                }
            } catch (error) {
                console.error('‚ùå Error checking for moves:', error);
            }
        }

        // Send initial game state to server (Host only)
        async function sendGameStateToServer() {
            if (!isMultiplayer || !roomCode) return;

            console.log('üì§ Host sending initial game state to server');

            try {
                const response = await fetch(`${API_URL}/api/rooms/move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roomCode: roomCode,
                        player: myPlayer,
                        action: { type: 'init', message: 'Initial game state' },
                        gameState: gameState
                    })
                });

                const data = await response.json();
                if (data.success) {
                    console.log('‚úÖ Initial game state sent to server');
                } else {
                    console.error('‚ùå Failed to send initial game state');
                }
            } catch (error) {
                console.error('‚ùå Error sending initial game state:', error);
            }
        }

        // Fetch initial game state from server (Guest only)
        async function fetchGameStateFromServer() {
            if (!isMultiplayer || !roomCode) return;

            console.log('üì• Guest fetching initial game state from server');

            try {
                const response = await fetch(`${API_URL}/api/rooms/moves/${roomCode}/0`);
                const data = await response.json();

                if (data.success && data.gameState) {
                    console.log('‚úÖ Initial game state fetched from server');
                    gameState = data.gameState;
                    console.log('üéÆ Game state loaded:', gameState);

                    renderBoard();
                    updateUI();
                    updatePieceSelector();
                } else {
                    console.warn('‚ö†Ô∏è No game state on server yet, using default');
                    gameState = createGame('Opponent', username);
                    renderBoard();
                    updateUI();
                    updatePieceSelector();
                }
            } catch (error) {
                console.error('‚ùå Error fetching initial game state:', error);
                // Fallback to default game state
                gameState = createGame('Opponent', username);
                renderBoard();
                updateUI();
                updatePieceSelector();
            }
        }

        // Start polling for moves
        function startMovePolling() {
            console.log('üîÑ Starting move polling...');
            // Poll every 1 second
            pollInterval = setInterval(checkForOpponentMoves, 1000);
        }

        // Initialize on load - wait for DOM to be ready
        window.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ DOM loaded, initializing game...');

            // Set up difficulty change handler
            const difficultySelect = document.getElementById('difficulty');
            if (difficultySelect) {
                difficultySelect.onchange = function() {
                    difficulty = this.value;
                    console.log('üéØ Difficulty changed to:', difficulty);
                };
            }

            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>
